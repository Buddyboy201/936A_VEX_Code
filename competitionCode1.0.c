#pragma config(Motor,  port2,           frontRight,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           backRight,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           backLeft,      tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           armRight,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           armLeft,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           clawTilt,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           clawOpen,      tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void armUp(){
		motor[armLeft] = -120;
		motor[armRight] = -120;
}

void armDown(){
		motor[armLeft] = 120;
		motor[armRight] = 120;
}

void stopArm(){
	motor[armLeft] = 0;
	motor[armRight] = 0;
}

void tiltClawUp(){
	motor[clawTilt] = 120;
}

void tiltClawDown(){
	motor[clawTilt] = -120;
}

void stopTilt(){
	motor[clawTilt] = 0;
}

void clawO(){
	motor[clawOpen] = 50;
}

void clawC(){
	motor[clawOpen] = -120;
}

void clawS(){
	motor[clawOpen] = 0;
}

task main()
{
		int channelvar_two = 0;
		int channelvar_three = 0;
		int channelvar_four = 0;
		int threshold = 15;

		while(1==1){
			//creating a deadzone for channel 2
			if (abs(vexRT[Ch2]) > threshold){
				channelvar_two = vexRT[Ch2];
				}
			else{
				channelvar_two= 0;
			}

			//creating a deadzone for channel 3
			if (abs(vexRT[Ch3]) > threshold){
				channelvar_three = vexRT[Ch3];
				}
			else{
				channelvar_three = 0;
			}

			//creating a deadzone for channel 4
			if (abs(vexRT[Ch4]) > threshold){
				channelvar_four = vexRT[Ch4];
				}
			else{
				channelvar_four = 0;
			}

			//moving the robot

			motor[frontRight] = channelvar_three - channelvar_four - channelvar_two;
			motor[backRight] = channelvar_three - channelvar_four + channelvar_two;
			motor[frontLeft]  = channelvar_three + channelvar_four + channelvar_two;
			motor[backLeft]  = channelvar_three + channelvar_four - channelvar_two;

			while(vexRT[Btn7U]== 1){
				armUp();
			}
			if(vexRT[Btn7D]== 1){
				armDown();
			}
			if(vexRT[Btn7L]==1){
				stopArm();
			}
			if(vexRT[Btn8U]== 1){
				tiltClawUp();
			}
			if(vexRT[Btn8D]== 1){
				tiltClawDown();
			}
			if(vexRT[Btn8L]==1){
				stopTilt();
			}
			if(vexRT[Btn6U] == 1){
				clawS();
				clearTimer(T3);
				while(time1[T3]<50){
					clawO();
				}
				clawS();
			}
			if(vexRT[Btn6D]== 1){
				clawC();
			}
			if(vexRT[Btn6D] == 0){
				clawS();
			}
	}
}
